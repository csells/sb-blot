# A Young Software Engineer's Guide to AI

I had a lovely conversation with a software engineer newly graduated from college. He said that he struggled sometimes; he doesn't feel like he's got a "coding instinct" like someone that's spent their career writing code "by hand" and living with the consequences. He said that he was able to be productive immediately in his job but that -- and this is the core of what he said -- **he didn't always understand the code that the AI was writing**. He submitted it for review and it got shipped anyway, but he had a question for me:

> **Q: How am I going to develop a "coding instinct" without writing the code myself?**

That question gets to the heart of the matter. How did I develop those instincts? I told him that I sepnt a lot of time reading other people's code, whether it was in books, discussion groups or mailing lists. Of course, I've spent a lot of time debugging other people's code and fixing their mistakes. And making my own mistakes. Lots and lots of mistakes.

When I hire engineers, I hire based on whether they understand the "why" behind whatever they claim to know the best. Software engineering is all about understanding the why. I care less about whether a potential hire knows the specifics of the tech we're going to ask them to use at the moment. I care much more about whether they understand what they consider themselves an expert in to the level that I can drill in several levels of "why" questions.

Here's the thing: you don't have to wait for Friday's lunch-and-learn anymore to discuss the code you read about in McConnel's "Writing Solid Code" or TODO's "Software Pearls". You can ask the AI to explain itself to you. When you see code you don't understand, ask questions. Why did it choose that approach? What other options were available? Is that the right solution for the problem we're addressing got? I do that ALL the time. Often I learn things (I'm still reading other people's code). Sometimes it removes questional code.

And all you have to do is ask *"why?"*

## The Changing Landscape

> “The future is already here – it’s just not very evenly distributed.” –W. Gibson

I have a friend who runs 10 instances of Devin at a time in his job. I know an engineering manager who has no desire to hire more software engineers; he's got plenty. We haven't recovered from the layoffs, and salaries are down for new hires.

These are effects of a larger cause: AI is the biggest change in the software industry since we moved from submitting jobs in batch to interactive multi-user systems. We're seeing engineers using AI becoming more effective than engineers who don't.

But not everyone is on board.

## The Spectrum of Change

Think of it as a dial that's slowly turning:

- Engineers in denial
- Engineers using coding tools
- Engineers using Jira tickets to drive coding LLMs
- Engineers using LLMs for code reviews
- Engineers building CI/CD pipelines using LLMs
- Non-engineers building analytics analysis using LLMs
- (Future) Engineers using LLMs to monitor logs for errors, performance issues, security breaches, abuse
- (Future) LLMs pulling Jira tickets off the queue

At some point, issue reporting becomes a way for humans and "admin" LLMs to communicate with "eng" LLMs. Office Space wasn't wrong: someone's job becomes bringing the link from Jira to the LLM.

## What This Means for You

I've been telling people for ten years that AI is replacing software engineering. Classical AI -- machine learning, supervised learning, etc. -- has been replacing the core algorithms in our software for a while now. Generative AI just accelerates that.

All of our tools, programming languages, and frameworks are designed for humans and their need for developer experience. By definition, they're non-optimal for the task at hand if an AI is doing the work.

So what does this mean for the future of software engineering as a profession?

In the short term, keep asking why. Use AI as your tireless pair programming partner who never gets frustrated with your questions. The AI can explain its reasoning, suggest alternatives, and help you understand the trade-offs.

Do we need engineers reading and writing code? Why do we need that if the LLM is doing the bug fixing and feature implementation? How many more custom apps will we need? Doesn't the LLM, sufficiently capable, become the final app? I write throwaway spreadsheets all the time. Now I'm writing throwaway apps.

Maybe we stall out somewhere along the way. Maybe we don't.

But right now, in this moment, you have an unprecedented opportunity to learn from a patient teacher that never gets tired of explaining the same concept in different ways until you get it.

Take advantage of that. Ask why. Keep asking why.

Your coding instincts will develop just fine.