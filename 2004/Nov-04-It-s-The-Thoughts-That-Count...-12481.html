<!--
Date: 11/4/2004 12:00:00 AM  -08:00
Permalink: 12481
Disqus: 12481
Tags: spout
-->
<h1>It's The Thoughts That Count...</h1>
<p align="left">On an internal mailing list the other day, there was a question asking for how to make a tray notification icon come back up on the try after explorer.exe died and came back to life. Good notification icons do this and the asker wanted to know how to do it for Windows Forms. I had had a dearth of technical work at the time, so decided to dig into the problem and see if I could answer it.</p><p align="left">I started with a dim memory of a piece in MSJ by Paul Dilascia on the subject. Searching on msdn.com, I found Paul DiLascia's 2/99 MSJ C++ Q&amp;A (<a href="http://www.microsoft.com/msj/0299/c/c0299.aspx">http://www.microsoft.com/msj/0299/c/c0299.aspx</a>) (emphasis added by me):</p><blockquote><p align="left"><i>&quot;provided you have Windows 98 or the Microsoft Internet Explorer 4.0 desktop installed. Whenever Internet Explorer 4.0 starts the taskbar, it broadcasts <b>a registered message TaskbarCreated</b> to all top-level parent windows. This is your cue to recreate the icons. If you're using MFC, all you have to do is define a global variable to hold the registered message and implement an ON_REGISTERED_MESSAGE handler for it.&quot;</i></p></blockquote><p align="left">From there, I dug through the SDK docs on ON_REGISTERED_MESSAGE (<a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmfc98/html/_mfc_on_registered_message.asp">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmfc98/html/_mfc_on_registered_message.asp</a>) and found:</p><blockquote><p align="left"><b><i>// example for ON_REGISTERED_MESSAGE<br>const UINT wm_Find = RegisterWindowMessage( FINDMSGSTRING )</i></b></p><p align="left"><i>BEGIN_MESSAGE_MAP( CMyWnd, CMyParentWndClass )<br>//{{AFX_MSG_MAP( CMyWnd )<br>&nbsp; ON_REGISTERED_MESSAGE( wm_Find, OnFind )<br>// ... Possibly more entries to handle additional messages<br>//}}AFX_MSG_MAP<br>END_MESSAGE_MAP( )</i></p></blockquote><p align="left">Figuring I'd have to be able to call RegisterWindowsMessage from managed code, I surfed to pinvoke.net and found RegisterWindowMessage (<a href="http://pinvoke.net/default.aspx/user32.RegisterWindowMessage">http://pinvoke.net/default.aspx/user32.RegisterWindowMessage</a>):</p><blockquote><p align="left"><i>[DllImport(&quot;user32.dll&quot;, SetLastError=true, CharSet=CharSet.Auto)]<br>static extern uint RegisterWindowMessage(string lpString);</i></p></blockquote><p align="left">Now that I knew how to figure out the Window message value for which to watch, I looked back into the MSDN documentation on System.Windows.Forms.Control, the base class of Form and all other HWND-based classes in Windows Forms (<a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfsystemwindowsformscontrolclasswndproctopic.asp">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfsystemwindowsformscontrolclasswndproctopic.asp</a>) and the WndProc method I would have to override to catch the message, finding:</p><blockquote><p align="left"><i>protected virtual void WndProc(<br>ref Message m<br>);</i></p></blockquote><p align="left">and:</p><blockquote><p align="left"><i>&quot;All messages are sent to the WndProc method after getting filtered through the PreProcessMessage method.</i></p><p align="left"><i>&quot;The WndProc method corresponds exactly to the Windows WindowProc function. For more information about processing Windows messages, see the WindowProc function documentation in the Windows Platform SDK reference located in the MSDN Library.</i></p><p align="left"><i>&quot;Notes to Inheritors: Inheriting controls should call the base class's WndProc method to process any messages that they do not handle.&quot;</i></p></blockquote><p align="left">Putting this together, I figured you could add &quot;re-awakening&quot; to notification icons in the following way (some compiler errors left in to keep readers on their toes : ):</p><blockquote><p align="left"><i>using System.Windows.Forms;<br>using System.Runtime.InteropServices;<br><br>class MyMainForm : Form {<br>&nbsp; [DllImport(&quot;user32.dll&quot;, SetLastError=true, CharSet=CharSet.Auto)]<br>&nbsp; static extern uint RegisterWindowMessage(string lpString);<br><br>&nbsp; static uint taskbarCreatedMessage = RegisterWindowMessage(&quot;TaskbarCreated&quot;);<br><br>&nbsp; protected override void WndProc(ref Message m) {<br>&nbsp;&nbsp;&nbsp; if( (uint)m.Msg == taskbarCreatedMessage ) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // re-show your notify icon<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; base.WndProc(ref m);<br>&nbsp; }<br>&nbsp; <br>}</i></p></blockquote><p align="left">After posting this answer to the list, I couldn't help but crank up a quick app to test it (after fixing the compiler errors of course : ). To my satisfaction, it worked immediately. I put up a notify icon in Windows Forms, killed explorer.exe and was pleased to see my icon show back up again when explorer.exe was restarted.</p><p align="left">However, just to make sure, I commented out my code to see my icon not be restored. Those of you familiar with the internals of Windows Forms know what happened next, of course, because my notify icon was restored properly to the tray even without my code, as illustrated by Reflector against the .NET 1.1 Windows Forms implementation:</p><blockquote><p align="left"><i>public sealed class NotifyIcon : Component {<br>&nbsp; ...<br><b>&nbsp; static NotifyIcon() {<br>&nbsp;&nbsp;&nbsp;&nbsp; NotifyIcon.WM_TASKBARCREATED =<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SafeNativeMethods.RegisterWindowMessage(&quot;TaskbarCreated&quot;);<br>&nbsp; }<br></b><br><b>&nbsp; private void WmTaskbarCreated(ref Message m) {<br>&nbsp;&nbsp;&nbsp; this.added = false;<br>&nbsp;&nbsp;&nbsp; this.UpdateIcon(this.visible);<br>&nbsp; }<br><br>&nbsp; private void WndProc(ref Message msg) {<br>&nbsp;&nbsp;&nbsp; ...<br>&nbsp;&nbsp;&nbsp; if (msg.Msg == NotifyIcon.WM_TASKBARCREATED) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.WmTaskbarCreated(ref msg);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; ...<br>&nbsp; }<br></b>&nbsp; ...<br><b>&nbsp; private static int WM_TASKBARCREATED;<br></b>&nbsp; ...<br>}</i></p></blockquote><p align="left">What? Why would someone post a question about how to make something work that already worked? I figured that the questioner was referring to .NET 1.0 and I was digging through .NET 1.1 code.</p><p align="left">However, reading through the 1.0 code showed the same support, meaning that neither the questioner nor I had bothered to check for this support before running off to add it. So, the lesson? Write your tests first!</p><p align="left">Still, I learned a bit along the way and that was fun. : )</p>
