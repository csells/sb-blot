<!--
Date: 2/7/2010 12:02:46 PM  -08:00
Permalink: 2326
Disqus: 2326
Tags: .net
-->
<h1>Data Binding, Currency and the WPF TreeView</h1>
<img align=right src="/public/tools/ode1.jpg" width=328 height=219> 
<P>I was building a little WPF app to explore a hierarchical space (<A href="http://odata.org/">OData</A>, if you must know), so of course, I was using the TreeView. And since I'm a big fan of data binding, of course I've got a hierarchical data source (basically):</P><PRE>abstract class Node {<BR>  public abstract string Name { get; }<BR>&nbsp; public abstract IEnumerable&lt;Node&gt; { get; }<BR>  public XDocument Document { get { ... } }<BR>  public Uri Uri { get { ... } }<BR>}</PRE>
<P>I then bind to the data source (of course, you can do this in XAML, too):</P><PRE>// set the data context of the grid containing the treeview and text boxes<BR>grid.DataContext = new Node[] { Node.GetNode(new Uri(uri)) };</PRE><PRE>// bind the treeview to the entire collection of nodes<BR>leftTreeView.SetBinding(TreeView.ItemsSourceProperty, ".");</PRE><PRE>// bind each text box to a property on the current node<BR>queryTextBox.SetBinding(TextBox.TextProperty,<BR>&nbsp; new Binding("Uri") { Mode = BindingMode.OneWay });<BR>documentTextBox.SetBinding(TextBox.TextProperty,<BR>&nbsp; new Binding("Document") { Mode = BindingMode.OneWay });</PRE>
<P>What we're trying to do here is leverage the idea of "currency" in WPF where if you share the same data context, then item controls like textboxes will bind to the "current" item as it's changed by the list control. If this was a listview instead of a treeview, that would work great (so long as you set the IsSynchronizedWithCurrentItem property to true).</P>
<P>The problem, as <a href="/public/writing/wpfbook/">my co-author</A> and the-keeper-of-all-WPF-knowledge <A href="http://www.interact-sw.co.uk/iangblog/">Ian Griffiths</A> reminded me this morning,&nbsp;is that currency is based on a single collection, whereas a TreeView control is based on multiple collections, i.e. the one at the root and each one at sub-node, etc. So, as I change the selection on the top node, the treeview has no single collection's current item to update (stored in an associated "view" of the data), so it doesn't update anything. As the user navigates from row to row, the "current" item never changes and our textboxes are not updated.</P>
<P>So, Ian informed me of a common "hack" to solve this problem. The basic idea is to forget about the magic "current node" and&nbsp;explicitly bind each control to the treeview's SelectedItem property. As it changes, regardless of which collection from whence the item came, each item control is updated, as data binding is supposed to work.</P>
<P>First, instead of setting the grid's DataContext to the actual data, shared with the treeview and the textboxes, we bind it to the currently selected treeview item:</P><PRE>// bind the grid containing the treeview and text boxes<BR>// to point at the treeview's currently selected item<BR>grid.DataContext = new Binding("SelectedItem") { ElementName = "leftTreeView" };</PRE>
<P>Now, because we want the treeview to in fact show our hierarchical collection of nodes, we set it's DataContext explicitly:</P><PRE>// set the treeview's DataContext to be the data we want it to show<BR>leftTreeView.DataContext = new Node[] { Node.GetNode(new Uri(uri)) };</PRE>
<P>Now, the treeview will show the data we wanted it to show, as before, but as the user changes the selection, the treeview's SelectedItem property changes, which updates the grid's DataContext, which signals the textboxes, bound to properties on grid's DataContext (because the DataContext property is inherited and we haven't overridden it on the textboxes), and the textboxes are updated.</P>
<P>Or, in other words, the textboxes effectively have a new idea of the "current" item that meshes with how the treeview works. Thanks, Ian!</P>
