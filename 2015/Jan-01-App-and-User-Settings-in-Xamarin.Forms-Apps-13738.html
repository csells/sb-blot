<!--
Date: 1/1/2015 6:09:39 PM  -08:00
Permalink: 13738
Disqus: 13738
Tags: .net,spout
-->
<h1>App and User Settings in Xamarin.Forms Apps</h1>
<p>Settings allow you to separate the parameters that configure the behavior of your app separate from the code, which allows you to change that behavior without rebuilding the app. This is handle at the app level for things like server addresses and API keys and at the user level for things like restoring the last user input and theme preferences. Xamarin.Forms provides direct support for neither, but that doesn’t mean you can’t easily add it yourself.</p>  <h2>App Settings</h2>  <p>Xamarin.Forms doesn’t have any concept of the .NET standard app.config. However, it’s easy enough to add the equivalent using embedded resources and the XML parser. For example, I built a Xamarin.Forms app for finding spots for coffee, food and drinks between where I am and where my friend is (<a href="https://github.com/csells/middlemeeter">MiddleMeeter, on GitHub</a>). I’m using the Google APIs to do a bunch of geolocation-related stuff, so I need a Google API key, which I don’t want to publish on GitHub. The easy way to make that happen is to drop the API key into a separate file that’s loaded at run-time but to not check that file into GitHub by adding it to .gitignore. To make it easy to read, I added this file as an Embedded Resource in XML format:</p>  <p><a href="/public/post-images/13738-256.png"><img title="image" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="image" src="/public/post-images/13738-257.png" width="371" height="480" /></a></p>  <p><em>Adding an XML file as an embedded resource makes it easy to read at run-time for app settings</em></p>  <p>I could’ve gone all the way and re-implemented the entire .NET configuration API, but that seemed like overkill, so I kept the file format simple:</p>  <pre class="code"><span style="background: white; color: blue">&lt;?</span><span style="background: white; color: #a31515">xml </span><span style="background: white; color: red">version</span><span style="background: white; color: blue">=</span><span style="background: white; color: black">&quot;</span><span style="background: white; color: blue">1.0</span><span style="background: white; color: black">&quot; </span><span style="background: white; color: red">encoding</span><span style="background: white; color: blue">=</span><span style="background: white; color: black">&quot;</span><span style="background: white; color: blue">utf-8</span><span style="background: white; color: black">&quot; </span><span style="background: white; color: blue">?&gt;
&lt;</span><span style="background: white; color: #a31515">config</span><span style="background: white; color: blue">&gt;
  &lt;</span><span style="background: white; color: #a31515">google-api-key</span><span style="background: white; color: blue">&gt;</span><span style="background: white; color: black">YourGoogleApiKeyHere</span><span style="background: white; color: blue">&lt;/</span><span style="background: white; color: #a31515">google-api-key</span><span style="background: white; color: blue">&gt;
&lt;/</span><span style="background: white; color: #a31515">config</span><span style="background: white; color: blue">&gt;</span></pre>

<p>Loading the file at run-time uses the normal .NET resources API:</p>

<pre class="code"><span style="background: white; color: blue">string </span><span style="background: white; color: black">GetGoogleApiKey() {
</span><span style="background: white; color: green">  </span><span style="background: white; color: blue">var </span><span style="background: white; color: black">type = </span><span style="background: white; color: blue">this</span><span style="background: white; color: black">.GetType();
  </span><span style="background: white; color: blue">var </span><span style="background: white; color: black">resource = type.Namespace + </span><span style="background: white; color: #a31515">&quot;.&quot; </span><span style="background: white; color: black">+<br />    </span><span style="background: white; color: #2b91af">Device</span><span style="background: white; color: black">.OnPlatform(</span><span style="background: white; color: #a31515">&quot;iOS&quot;</span><span style="background: white; color: black">, </span><span style="background: white; color: #a31515">&quot;Droid&quot;</span><span style="background: white; color: black">, </span><span style="background: white; color: #a31515">&quot;WinPhone&quot;</span><span style="background: white; color: black">) + </span><span style="background: white; color: #a31515">&quot;.config.xml&quot;</span><span style="background: white; color: black">;
  </span><span style="background: white; color: blue">using </span><span style="background: white; color: black">(</span><span style="background: white; color: blue">var </span><span style="background: white; color: black">stream = type.Assembly.GetManifestResourceStream(resource))
  </span><span style="background: white; color: blue">using </span><span style="background: white; color: black">(</span><span style="background: white; color: blue">var </span><span style="background: white; color: black">reader = </span><span style="background: white; color: blue">new </span><span style="background: white; color: #2b91af">StreamReader</span><span style="background: white; color: black">(stream)) {
    </span><span style="background: white; color: blue">var </span><span style="background: white; color: black">doc = </span><span style="background: white; color: #2b91af">XDocument</span><span style="background: white; color: black">.Parse(reader.ReadToEnd());
    </span><span style="background: white; color: blue">return </span><span style="background: white; color: black">doc.Element(</span><span style="background: white; color: #a31515">&quot;config&quot;</span><span style="background: white; color: black">).Element(</span><span style="background: white; color: #a31515">&quot;google-api-key&quot;</span><span style="background: white; color: black">).Value;
  }
}</span></pre>

<p>I used XML as the file format not because I’m in love with XML (although it does the job well enough for things like this), but because LINQ to XML is baked right into Xamarin. I could’ve used JSON, too, of course, but that requires an extra NuGet package. Also, I could’ve abstracting things a bit to make an easy API for more than one config entry, but I’ll leave that for enterprising readers.</p>

<h2>User Settings</h2>

<p>While app settings are read-only, user settings are read-write and each of the supported Xamarin platforms has their own place to store settings, e.g. .NET developers will likely have heard of Isolated Storage. Unfortunately, Xamarin provides no built-in support for abstracting away the platform specifics of user settings. Luckily, <a href="https://twitter.com/jamesmontemagno">James Montemagno</a> has. In his <a href="https://www.nuget.org/packages/Xam.Plugins.Settings/">Settings Plugin NuGet package</a>, he makes it super easy to read and write user settings. For example, in my app, I pull in the previously stored user settings when I’m creating the data model for the view on my app’s first page:</p>

<pre class="code"><span style="background: white; color: blue">class </span><span style="background: white; color: #2b91af">SearchModel </span><span style="background: white; color: black">: </span><span style="background: white; color: #2b91af">INotifyPropertyChanged </span><span style="background: white; color: black">{
  </span><span style="background: white; color: blue">string </span><span style="background: white; color: black">yourLocation;
<strong>  </strong></span><strong><span style="background: white; color: green">// reading values saved during the last session (or setting defaults)
  </span><span style="background: white; color: blue">string </span><span style="background: white; color: black">theirLocation = </span><span style="background: white; color: #2b91af">CrossSettings</span><span style="background: white; color: black">.Current.GetValueOrDefault(</span><span style="background: white; color: #a31515">&quot;theirLocation&quot;</span><span style="background: white; color: black">, </span><span style="background: white; color: #a31515">&quot;&quot;</span></strong><strong><span style="background: white; color: black">);
  </span><span style="background: white; color: #2b91af">SearchMode </span><span style="background: white; color: black">mode = </span><span style="background: white; color: #2b91af">CrossSettings</span><span style="background: white; color: black">.Current.GetValueOrDefault(</span><span style="background: white; color: #a31515">&quot;mode&quot;</span><span style="background: white; color: black">, </span><span style="background: white; color: #2b91af">SearchMode</span></strong><span style="background: white; color: black"><strong>.food);
</strong>  </span><span style="background: white; color: green">...
</span><span style="background: white; color: black">}</span></pre>


<p>The beauty of James’s API is that it’s concise (only one function to call to get a value or set a default if the value is missing) and type-safe, e.g. notice the use of a string and an enum here. He handles the specifics of reading from the correct underlying storage mechanism based on the platform, translating it into my native type system and I just get to write my code w/o worrying about it. Writing is just as easy:</p>

<pre class="code"><span style="background: white; color: blue">async void </span><span style="background: white; color: black">button1_Clicked(</span><span style="background: white; color: blue">object </span><span style="background: white; color: black">sender, </span><span style="background: white; color: #2b91af">EventArgs </span><span style="background: white; color: black">e) {
  </span><span style="background: white; color: blue">...</span><span style="background: white; color: black">

<strong>  </strong></span><strong><span style="background: white; color: green">// writing settings values at an appropriate time
  </span><span style="background: white; color: #2b91af">CrossSettings</span><span style="background: white; color: black">.Current.AddOrUpdateValue(</span><span style="background: white; color: #a31515">&quot;theirLocation&quot;</span></strong><strong><span style="background: white; color: black">, model.TheirLocation);
  </span><span style="background: white; color: #2b91af">CrossSettings</span><span style="background: white; color: black">.Current.AddOrUpdateValue(</span><span style="background: white; color: #a31515">&quot;mode&quot;</span></strong><span style="background: white; color: black"><strong>, model.Mode);
</strong>
  ...</span><span style="background: white; color: black">
}</span></pre>


<p>My one quibble is that I wish the functions were called Read/Write or Get/Set instead of GetValueOrDefault/AddOrUpdateValue, but James’s function names make it very clear what’s actually happening under the covers. Certainly the functionality makes it more than worth the extra characters.</p>

<h2>User Settings UI</h2>

<p>Of course, when it comes to building a UI for editing user settings at run-time, Xamarin.Forms has all kinds of wonderful facilities, including a TableView intent specifically for settings (TableIntent.Settings). However, when it comes to extending the platform-specific Settings app, you’re on your own. That’s not such a big deal, however, since only iOS actually supports extending the Settings app (using <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/UserDefaults/Preferences/Preferences.html">iOS Settings Bundles</a>). Android doesn’t support it at all (they only let the user configure things like whether an app has permission to send notifications) and while Windows Phone 8 has an extensible Settings Hub for their apps, it’s <a href="http://www.dennisdel.com/?p=223">a hack if you do it with your own apps</a> (and unlikely to make it past the Windows Store police).</p>

<h2>Where Are We?</h2>

<p>So, while Xamarin.Forms doesn’t provide any built in support for app or user settings, the underlying platform provides enough to make implementing the former trivial and the Xamarin ecosystem provides nicely for the latter (thanks, James!).</p>

<p>Even more interesting is what Xamarin has enabled with this ecosystem. They’ve mixed their very impressive core .NET and C# compiler implementation (Mono) with a set of mobile libraries providing direct access to the native platforms (MonoTouch and MonoDroid), added a core implementation of UI abstraction (Xamarin.Forms) and integration into the .NET developer’s IDE of choice (Visual Studio) together with an extensible, discoverable set of libraries (NuGet) that make it easy for 3rd party developers to contribute. That’s a platform, my friends, and it’s separate from the one that Microsoft is building. What makes it impressive is that it takes the army of .NET developers and points them at the current hotness, i.e. building iOS and Android apps, in a way that Microsoft never could. Moreover, because they’ve managed to also support Windows Phone pretty seamlessly, they’ve managed to get Microsoft to back them.</p>

<p>We’ll see how successful Xamarin is over time, but they certainly have a very good story to tell .NET developers.</p>  
